global start

section .text

length:; Length runtime function
push r12
mov rax, 0; Set length count to 0
length_loop:; Count another charachter
movsx r11, byte [r8]; Load char into memory
cmp r11, 0; If char is null, end of string. Return count.
jz length_return; If char is null, end of string. Return count.
inc rax;; Bump string index
inc r8;; Bump length counter
jmp length_loop; Go count another char
length_return:; Done
pop r12
ret; Done
print:; Print: string->
call length; Call length on argument so we can pass it to write(2). (Arugment is already in argument register)
mov rdi, 1; Load stdout fd into argument 1 of write(2) (stdout fd is 1) syscallArg1: rdi
mov rsi, r8; Put string ptr in arg 2 of write(2)
mov rdx, rax; 3rd argument to write(2) is length
mov rax, 33554436; Select print
mov rdi, r8; Move print argument to syscall argument
mov rdi, r8; Move print argument to syscall argument
syscall; Print
mov rax, rax; Move syscall result to function result
ret; Return
string_copy:; string_copy
push r12
string_copy_loop:; Copy a byte
movsx r11, byte [r8]; Load byte from input
mov byte [r9], r11b; Write it to output
cmp r11, 0; If char was the null terminator, return
jz string_copy_return; If char was the null terminator, return
inc r8;; Bump pointers to next char
inc r9;; Bump pointers to next char
jmp string_copy_loop; Copy next char
string_copy_return:;
pop r12
ret; Done
my_malloc:; Alloc via mmap
push r14
push r13
push r12
cmp r8, 0; Error if no memory requested
jne my_malloc_zero_size_check_passed; Error if no memory requested
lea rdi, [rel zero_memory_malloc_error]; Error to print
mov rax, 33554436; Select print syscall
syscall; Print
mov rax, 33554433; Select exit syscall
syscall; Exit
my_malloc_zero_size_check_passed:; Done checking for zero size
lea r11, [rel first_block]; Start checking for a free block starting at the first
mov r12, 0; No previous pointer yet
find_large_enough_free_block_loop:; Find a block
cmp r11, 0; No blocks left (will require mmap)
jz found_large_enough_block; No blocks left (will require mmap)
mov r13, [r11]; Current block not free, load next block
cmp r13, 0; Check next block
jz advance_pointers; Check next block
mov r13, [r11]; Current block not large enough, try next
cmp r13, r8; Check next block if current not large enough
jg advance_pointers; Check next block if current not large enough
jmp found_large_enough_block; We found a large enough block! Hooray!
advance_pointers:; Bump pointers to next block
mov r12, r11; Advance current block pointer to previous.
mov r11, [r11]; Advance block->next to current pointer
jmp find_large_enough_free_block_loop; Didn't find a block, try again
found_large_enough_block:; Found a block
cmp r11, 0; No good blocks, so make one
jz mmap_more_space; No good blocks, so make one
mov byte [r11], 0; Found a reusable block, mark it as not free
mov rax, r11; Return current block pointer
add rax, 24; Adjust pointer to point to allocated space instead of management struct
jmp my_malloc_return; Found good existing block
mmap_more_space:; Here we mmap a new block
mov rdi, 0; addr arg, use null
mov rsi, r8; len arg, amound of memory to allocate
add rsi, 24; Add space for management block
mov rdx, 3; prot arg, 3 = PROT_READ|PROT_WRITE
mov r10, 4098; flags arg, 0x1002 = MAP_ANON | MAP_PRIVATE (according to dtruss)
mov r8, -1; fd arg, unused, set to -1 just in case
mov r9, 0; offset arg, unused, set to 0
mov rax, 33554629; Select malloc for calling
syscall; mmap
cmp rax, -1; If mmap failed, exit
jne mmap_exit_check_passed; If mmap failed, exit
lea rdi, [rel sbrk_failed]; Load string to print
mov rax, 33554436; Prepare to print
syscall; Print
mov rax, 33554433; Prepare to exit
syscall; Exit
mmap_exit_check_passed:; [object Object] now contains pointer to block. Set up pointer to new block.
mov r13, [rel first_block]; Load first block so we can write to it if necessary
cmp r13, 0; If there is no previous block, set up first block pointer
jne assign_previous; If there is no previous block, set up first block pointer
mov [rel first_block], rax; Setup first block pointer
jmp set_up_new_space;
assign_previous:; Set up prevous block pointer
cmp r12, 0;
jz set_up_new_space;
mov [r12], rax; prev->next = new
set_up_new_space:;
mov [rax], r8; new->size = requested_size
mov byte [rax], 0; new->next = null
mov byte [rax], 0; new->free = false
mov rax, rax; Return result of sbrk
add rax, 24; Adjust result pointer to point to actuall space, not management block
my_malloc_return:; Done
pop r12
pop r13
pop r14
ret; Done
verify_no_leaks:; verify_no_leaks
push r13
push r12
lea r11, [rel first_block]; Load first block address
mov r11, [r11]; Load first block pointer
verify_no_leaks_loop:; verify_no_leaks_loop
cmp r11, 0;
jz verify_no_leaks_return;
mov r12, [r11]; data = block->free
cmp r12, 0; Don't error if free
jne verify_no_leaks_advance_pointers; Don't error if free
lea rdi, [rel leaks_found_error]; Error to print
mov rax, 33554436; Select Print Syscall
syscall; syscall
mov rax, 33554433; Select exit Syscall
syscall; syscall
verify_no_leaks_advance_pointers:; verify_no_leaks_advance_pointers
mov r11, [r11]; block = block->next
jmp verify_no_leaks_loop; Check next block
verify_no_leaks_return:;
pop r12
pop r13
ret; Done

start:
; Put Integer into temporary; Put Integer into temporary
# Put argument 0 in register
lea r8, [rel string_literal_1_samplestring]; Load string literal address into register
# call print
lea r13, [rel print]; Load runtime function
call r13; Call runtime function
mov r12, rax; Move result from rax into destination
mov [rel dummy], r12; Put Integer into global
mov r12, 1; Load number literal
mov rax, r12; Retrun previous expression
    mov rdi, rax; Move function call result to syscall arg
    mov rax, 0x02000001; system call for exit
    syscall

section .data
first_block: dq 0
string_literal_1_samplestring: db "sample_string", 0;
section .bss
dummy: resd 1
tried_to_free_null: resd 1
double_free: resd 1
sbrk_failed: resd 1
leaks_found_error: resd 1
zero_memory_malloc_error: resd 1
print_failed: resd 1
