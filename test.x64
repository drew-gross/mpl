global start

section .text
anonymous_1:; anonymous_1
push r12
; Store left side of product in temporary (r12)
mov r12, r8; Move from a ([object Object]) into destination (r12)
; Store right side of product in destination (r11)
mov r11, r9; Move from b ([object Object]) into destination (r11)
mov rax, r12; Multiply does rax * arg
mul r11
mov r11, rax; Multiply puts result in rax:rdx, move it to final destination
mov rax, r11; Retrun previous expression
pop r12
ret; End of anonymous_1
length:; Length runtime function
push r12
mov rax, 0; Set length count to 0
length_loop:; Count another charachter
movsx r11, byte [r8]; Load char into memory
cmp r11, 0; If char is null, end of string. Return count.
jz length_return; If char is null, end of string. Return count.
inc rax;; Bump string index
inc r8;; Bump length counter
jmp length_loop; Go count another char
length_return:; Done
mov r8, r8; Repair pointer passed in arg1 so caller can still use it
sub r8, rax; Repair pointer passed in arg1 so caller can still use it
pop r12
ret; Done
print:; Print: string->
call length; Call length on argument so we can pass it to write(2). (Arugment is already in argument register)
mov rdi, 1; Load stdout fd into argument 1 of write(2) (stdout fd is 1) syscallArg1: rdi
mov rsi, r8; Put string ptr in arg 2 of write(2)
mov rdx, rax; 3rd argument to write(2) is length
mov rax, 33554436; Select print
syscall; Print
mov rax, rax; Move syscall result to function result
ret; Return
stringEquality:; stringEquality
push r13
push r12
mov rax, 1; Assume equal. Write true to rax. Overwrite if difference found.
stringEquality_loop:; Check a char, (string*, string*) -> bool
movsx r11, byte [r8]; Load current left char into temporary
movsx r12, byte [r9]; Load current right char into temporary
cmp r11, r12; Inequal: return false
jne stringEquality_return_false; Inequal: return false
cmp r11, 0; Both side are equal. If both sides are null, return.
jz stringEquality_return; Both side are equal. If both sides are null, return.
inc r8;; Bump lhs to next char
inc r9;; Bump rhs to next char
jmp stringEquality_loop; Check next char
stringEquality_return_false:; stringEquality_return_false
mov rax, 0; Set result to false
stringEquality_return:;
pop r12
pop r13
ret; Return
string_copy:; string_copy
push r12
string_copy_loop:; Copy a byte
movsx r11, byte [r8]; Load byte from input
mov byte [r9], r11b; Write it to output
cmp r11, 0; If char was the null terminator, return
jz string_copy_return; If char was the null terminator, return
inc r8;; Bump pointers to next char
inc r9;; Bump pointers to next char
jmp string_copy_loop; Copy next char
string_copy_return:;
pop r12
ret; Done
my_malloc:; Alloc via mmap
push r14
push r13
push r12
cmp r8, 0; Error if no memory requested
jne my_malloc_zero_size_check_passed; Error if no memory requested
lea rdi, [rel zero_memory_malloc_error]; Error to print
mov rax, 33554436; Select print syscall
syscall; Print
mov rax, 33554433; Select exit syscall
syscall; Exit
my_malloc_zero_size_check_passed:; Done checking for zero size
lea r11, [rel first_block]; curr = &first_block
mov r11, [r11+0]; curr = *curr
mov r12, 0; prev = NULL
find_large_enough_free_block_loop:; Find a block
cmp r11, 0; No blocks left (will require mmap)
jz found_large_enough_block; No blocks left (will require mmap)
mov r13, [r11+16]; Current block not free, load next block
cmp r13, 0; Check next block
jz advance_pointers; Check next block
mov r13, [r11+0]; Current block not large enough, try next
cmp r13, r8; Check next block if current not large enough
jg advance_pointers; Check next block if current not large enough
jmp found_large_enough_block; We found a large enough block! Hooray!
advance_pointers:; Bump pointers to next block
mov r12, r11; prev = curr
mov r11, [r11+8]; curr = curr->next
jmp find_large_enough_free_block_loop; Didn't find a block, try again
found_large_enough_block:; Found a block
cmp r11, 0; No good blocks, so make one
jz mmap_more_space; No good blocks, so make one
mov byte [r11+16], 0; Found a reusable block, mark it as not free
mov rax, r11; Return current block pointer
add rax, 24; Adjust pointer to point to allocated space instead of management struct
jmp my_malloc_return; Found good existing block
mmap_more_space:; Here we mmap a new block
push rdi; Save registers before using them as syscall args
push rsi; Save registers before using them as syscall args
push rdx; Save registers before using them as syscall args
push r10; Save registers before using them as syscall args
push r8; Save registers before using them as syscall args
push r9; Save registers before using them as syscall args
mov rdi, 0; addr arg, use null
mov rsi, r8; len arg, amound of memory to allocate
add rsi, 24; Add space for management block
mov rdx, 3; prot arg, 3 = PROT_READ|PROT_WRITE
mov r10, 4098; flags arg, 0x1002 = MAP_ANON | MAP_PRIVATE (according to dtruss)
mov r8, -1; fd arg, unused, set to -1 just in case
mov r9, 0; offset arg, unused, set to 0
mov rax, 33554629; Select malloc for calling
syscall; mmap
pop r9; Restore registers after using them as syscall args
pop r8; Restore registers after using them as syscall args
pop r10; Restore registers after using them as syscall args
pop rdx; Restore registers after using them as syscall args
pop rsi; Restore registers after using them as syscall args
pop rdi; Restore registers after using them as syscall args
cmp rax, -1; If mmap failed, exit
jne mmap_exit_check_passed; If mmap failed, exit
lea rdi, [rel sbrk_failed]; Load string to print
mov rax, 33554436; Prepare to print
syscall; Print
mov rax, 33554433; Prepare to exit
syscall; Exit
mmap_exit_check_passed:; [object Object] now contains pointer to block. Set up pointer to new block.
mov r13, [rel first_block]; Load first block so we can write to it if necessary
cmp r13, 0; If there is no previous block, set up first block pointer
jne assign_previous; If there is no previous block, set up first block pointer
mov [rel first_block], rax; Setup first block pointer
jmp set_up_new_space;
assign_previous:; Set up prevous block pointer
cmp r12, 0;
jz set_up_new_space;
mov [r12+8], rax; prev->next = new
set_up_new_space:;
mov [rax+0], r8; new->size = requested_size
mov byte [rax+8], 0; new->next = null
mov byte [rax+16], 0; new->free = false
mov rax, rax; Return result of sbrk
add rax, 24; Adjust result pointer to point to actuall space, not management block
my_malloc_return:; Done
pop r12
pop r13
pop r14
ret; Done
my_free:; my_free
push r12
cmp r8, 0; Not freeing null check passed
jne free_null_check_passed; Not freeing null check passed
lea rdi, [rel tried_to_free_null]; Error to print
mov rax, 33554436; Select Print Syscal
syscall; Print
mov rax, 33554433; Select exit syscall
syscall; Print
free_null_check_passed:; free_null_check_passed
mov r11, 1; Need access to a 1
mov [r8+-8], r11; block->free = false
pop r12
ret; Return
string_concatenate:; string_concatenate
push r12
write_left_loop:; write_left_loop
movsx r11, byte [r8]; Load byte from left
cmp r11, 0; If found lefts null terminator, start copying right
jz copy_from_right; If found lefts null terminator, start copying right
mov byte [r10], r11b; Write byte to output
inc r8;; Bump left pointer
inc r10;; Bump out pointer
jmp write_left_loop; Loop to next char
copy_from_right:; copy_from_right
movsx r11, byte [r9]; Load byte from right
mov byte [r10], r11b; Write before checking for null terminator because we want to write null terminator
cmp r11, 0; If we just wrote a null terminator, we are done
jz concatenate_return; If we just wrote a null terminator, we are done
inc r9;; Bump right pointer
inc r10;; Bump out pointer
jmp copy_from_right; Go copy next char
concatenate_return:;
pop r12
ret; Return
verify_no_leaks:; verify_no_leaks
push r13
push r12
lea r11, [rel first_block]; Load first block address
mov r11, [r11+0]; Load first block pointer
verify_no_leaks_loop:; verify_no_leaks_loop
cmp r11, 0;
jz verify_no_leaks_return;
mov r12, [r11+16]; data = block->free
cmp r12, 0; Don't error if free
jne verify_no_leaks_advance_pointers; Don't error if free
lea rdi, [rel leaks_found_error]; Error to print
mov rax, 33554436; Select Print Syscall
syscall; syscall
mov rax, 33554433; Select exit Syscall
syscall; syscall
verify_no_leaks_advance_pointers:; verify_no_leaks_advance_pointers
mov r11, [r11+8]; block = block->next
jmp verify_no_leaks_loop; Check next block
verify_no_leaks_return:;
pop r12
pop r13
ret; Done

start:
lea r12, [rel anonymous_1]; Loading function into register
mov [rel times11], r12; Put Function into global
; Put argument ${index} in register
mov r8, 11; Load number literal
; Put argument ${index} in register
mov r9, 1; Load number literal
; call ${functionName}
mov r13, [rel times11]; Load global function pointer
call r13; Call global function
mov r12, rax; Move result from rax into destination
mov rax, r12; Retrun previous expression
    mov rdi, rax; Move function call result to syscall arg
    mov rax, 0x02000001; system call for exit
    syscall

section .data
first_block: dq 0

section .bss
times11: resq 1
tried_to_free_null: resd 1
double_free: resd 1
sbrk_failed: resd 1
leaks_found_error: resd 1
zero_memory_malloc_error: resd 1
print_failed: resd 1
