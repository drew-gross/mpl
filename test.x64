extern sbrk

global start

section .text

length:
push r8
mov rax, 0; Set length count to 0
length_loop:
movsx r8, byte [r8]
cmp r8, 0
jz length_return
inc rax;
inc r8;
jmp length_loop
length_return:
pop r8
ret
string_copy:
push r8
string_copy_loop:
movsx r8, byte [r8]
mov byte [r9], r8b
cmp r8, 0
jz string_copy_return
inc r8;
inc r9;
jmp string_copy_loop
string_copy_return:
pop r8
ret
my_malloc:
push r10
push r9
push r8
cmp r8, 0
jne my_malloc_zero_size_check_passed
mov rdi, zero_memory_malloc_error; Error to print
mov rax, 33554436; Select print syscall
syscall
mov rax, 33554433; Select exit syscall
syscall
my_malloc_zero_size_check_passed:
mov r8, first_block; Start checking for a free block starting at the first
mov r9, 0; No previous pointer yet
find_large_enough_free_block_loop:
cmp r8, 0
jz found_large_enough_block
mov r10, [r8]
cmp r10, 0
jz advance_pointers
mov r10, [r8]
cmp r10, r8
jg advance_pointers
jmp found_large_enough_block
advance_pointers:
mov r9, r8; Advance current block pointer to previous.
mov r8, [r8]
jmp find_large_enough_free_block_loop
found_large_enough_block:
cmp r8, 0
jz sbrk_more_space
mov byte [r8], 0
mov rax, r8; Return current block pointer
add rax, 24
jmp my_malloc_return
sbrk_more_space:
mov rdi, r8; Move amount of space to allocate to sbrk argument
add rdi, 24
call sbrk
jne sbrk_exit_check_passed
mov rdi, sbrk_failed; Load string to print
mov rax, 33554436; Prepare to print
syscall
mov rax, 33554433; Prepare to exit
syscall
sbrk_exit_check_passed:
mov r10, [rel first_block]; Load first block so we can write to it if necessary
cmp r10, 0
jne assign_previous
mov [rel first_block], rax; Setup first block pointer
jmp set_up_new_space
assign_previous:
cmp r9, 0
jz set_up_new_space
mov [r9], rax
set_up_new_space:
mov [rax], r8
mov byte [rax], 0
mov byte [rax], 0
mov rax, rax; Return result of sbrk
add rax, 24
my_malloc_return:
pop r8
pop r9
pop r10
ret

start:
mov r12, string_literal_1_test; Load string literal address into register
mov r8, r12; Put string pointer into temporary
call length; Get string length
inc rax;
mov r8, rax; Move length to argument1
call my_malloc; Allocate that much space
mov r8, r12; Move destination to argument 1
mov r9, rax; Move output pointer to argument 2
call string_copy; Copy string into allocated space
mov [rel myStr], rax; Store into global
# Put argument 0 in register
mov r8, [rel myStr]; Move from global myStr into destination (r8)
# call length
mov r13, length; Load runtime function
call r13; Call runtime function
mov r12, rax; Move result from rax into destination
mov rax, r12; Retrun previous expression
    mov rdi, rax; Move function call result to syscall arg
    mov rax, 0x02000001; system call for exit
    syscall

section .data
first_block: dq 0
message: db "Must have writable segment", 10; newline mandatory. This exists to squelch dyld errors
string_literal_1_test: db "test", 10;
section .bss
myStr: resd 1
tried_to_free_null: resd 1
double_free: resd 1
sbrk_failed: resd 1
leaks_found_error: resd 1
zero_memory_malloc_error: resd 1
print_failed: resd 1
